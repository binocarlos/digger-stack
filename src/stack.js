/*

  text
  
*/
module.exports = function(program){

  var Radio = require('digger-radio')
  var Digger = require('./digger');
  var App = require('./app');
  var logger = require('./logger');

  var $digger = Digger(program);
  var config = $digger.stack_config;

  // website only
  if(Object.keys(config.warehouses||{})<=0){
    App($digger)
    return;
  }

  var Reception = require('./reception');
  var Warehouse = require('./warehouse');

  var reception = Reception($digger);
  var warehouses = Warehouse($digger);
  var app = App($digger);

  // FRONT
  // pipe general requests to reception
  $digger.on('digger:request', function(req, res){
    process.nextTick(function(){
      reception(req, res);
    })
  });

  // BACK
  // requests going back to warehouses from reception
  reception.on('digger:warehouse', function(req, res){
    process.nextTick(function(){
      warehouses(req, function(error, results){
        res(error, results)
      });
    })
  })

  var fake_radio = Radio();

  /*
  
    BACK RADIO

    backend warehouse radio

    this happens when we change data and want to tell everyone else about it

    this is generated by the digger-supplier

    warehouse request -> radio message

    we are always writing to the radio from here
    
  */
  warehouses.on('digger:radio', function(channel, body){
    fake_radio.receive(channel, body);
    logger.radio('talk', channel);
  })

  /*
  
    USER RADIO
    
    user radio

    this is either a user socket or our application code using the radio manually

    we are faking it here - in a networked setup we would subscribe to the ZeroMQ pub socket here
    
  */
  $digger.on('digger:radio', function(action, channel, body){
    if(action=='listen'){
      fake_radio.listen(channel, body);
      logger.radio('listen', channel);
    }
    else if(action=='cancel'){
      fake_radio.cancel(channel, body); 
    }
    else if(action=='talk'){
      fake_radio.receive(channel, body);
      logger.radio('talk', channel);
    }
  })
}